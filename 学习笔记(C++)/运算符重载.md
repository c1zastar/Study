对于内置的数据类型, 编译器知道如何进行运算. 但是对于自定义类型, 编译器并不知道如何将他们相加
# 1 加号运算符重载

作用 : 实现两个自定义类型的相加

语法结构:
```c++
类名 operator+(类名 &对象1,类名 &对象2){
函数体
return 某一个对象;
}
```
==也可以直接使用匿名对象作为返回值, 这样可以精简函数==


加法运算符可以在类内进行重载, 但是这样就没有办法进行加法交换律了, 类内定义的运算符重载的左值必须是类的对象, 但是如果已经定义了有参构造函数的话, 是可以进行 对象+数字 的运算的(编译器根据构造函数自动转换,) ,但是如果在类内进行加号运算符的重载, 就没有办法进行数字+对象的操作, 因为数字不是对象
# 2 左移运算符重载

**核心本质:** `cout` 是 `ostream` 这个类里面的一个对象, 之所以能够实现`cout << 输出的内容;` 这个语句, 是因为对左移(<<)操作符进行了运算符的重载, 原理类似为:
```C++
初步重载:
void operator<< (ostream& cout , 输出的内容){
	内部的重载逻辑
}
但是这样还不行, 如果我们需要实现嵌套功能, 我们最好使函数的返回结果返回这个对象对应的引用
ostream& operator << (ostream &cout , 输出的内容){
	内部的重载逻辑
	return cout;
}
这样返回cout的引用之后, 可以实现返回cout的别名, 然后继续使用<<进行后续的输出, 形成链式传递
```
因此, 只要是`ostream的一个对象 << int/char等等默认的数据类型`, 编译器都会默认执行打印功能, 而ostream的对象并不一定是cout

而我们之所以需要左移运算符的重载, 是因为左移运算符在内置的重载逻辑里面只能进行int/char等等已知类型的重载, 不能进行自定义类型(如person类)的输出

通过上述的描述, 我们知道了我们需要的效果: `cout << 类.对象;` 这个结构是对左移运算符的重载, 同时为了实现链式传递, 我们必须规定运算符重载的返回值是cout的引用, 因此就有了左移运算符重载的基本框架:
```c++
ostream& operator<< (ostream &x,const 类 &y){
	x << y.属性;  y.属性必须是编译器的已知类型, 否则无法进行输出.
	return x;
}
```
==同时, 由于我们没有办法定义对象函数进行左移运算符的重载, 我们只能定义全局函数, 所以我们必须使用== **友元** ==进行函数权限的提升==
例如: `friend ostream& operator<< (ostream &x, const 类 &y);`


# 3 自增运算符重载

自增运算符分为两种:
* 前置自增运算符: 先进行自增, 然后进行返回, 因此必须要返回对应的对象
* 后置自增运算符: 返回值必须是自增之前的值, 同时还要保证相应的值得到了自增, 因此可以返回一个局部变量的值而不是返回引用, 同时为了和前置自增运算符的重载进行区分, 后置运算符的重载要加上站位函数(int)
* 站位函数: 可以不用定义变量, 但是函数引用的时候必须要赋值, 不能空着不写, 主要作用是匹配函数签名
```C++
#include <iostream>  
using namespace std;  
class Person{  
public:  
    friend Person& operator++(Person& p1);  
    friend Person operator++ (Person &p1,int);  
    friend ostream& operator<< (ostream &x,const Person & p);  
    Person(){}  
    Person(int i_age):age(i_age){}  
    Person(const Person&p){  
        age = p.age;  
    }  
private:  
    int age;  
};  
Person& operator++(Person& p1){  
    p1.age++;  
    return p1;  
}  
Person operator++ (Person& p1,int){  
    Person t(p1);  
    p1.age++;  
    return t;  
}  
ostream& operator<< (ostream &x,const Person & p){  
    x << p.age;  
    return x;  
}  
int main(){  
    Person man(19);  
    cout <<  man;  
    cout << ++man;  
    cout << man;  
    return 0;  
}
```


# 4 赋值运算符重载

作用: 主要是处理动态变量赋值之后不同对象占有同一块内存的bug

**注意:** 赋值运算符的重载有几个十分重要的点:
* 赋值运算符的重载只能作为类成员函数在类内定义
* 一定要添加拷贝构造函数
* 添加字符值检查
* 添加赋值对象是否为空的检查
* 构造析构函数删除动态内存
```c++
#include <iostream>
using namespace std;
class Person{
public:
	Person(){}
	Person(int i_age){
		age = new int (i_age);
	}
	Person (const Person& p){
		if(p.age != NULL){
			this->age = new int (*p.age);
		}
		else{
			this->age = NULL;
		}
	}
	~Person(){
		delete this->age;
	}
public:
	Person& operator= (const Person &p2){
		if(this == &p2){
			return *this;
		}
		delete this->age;
		if(p2.age != NULL){
			this->age = new int (*p2.age);
		}
		else 
			this->age = NULL;
		return *this;
	}
private:
	int* age = NULL;
};
```

# 5 关系运算符重载

关系运算符的重载比较简单, 只需要定义返回类型是bool类型就可, 我的推荐是作为全局函数定义在类外

```C++
bool operator 关系运算符(const & 类 对象1,const& 类 对象2){
	如果为真 return true;
	如果为假 return false;
}
然后再加上友元, 就完成了 
```

# 6 函数调用运算符重载(仿函数)

仿函数非常灵活, 没有固定的形式, 仿函数调用的时候与正常函数的区别可以说是对象的名称代替了函数的名称, 甚至可以直接进行匿名对象的仿函数调用,比如:
`类名 () (参数); //这里中间的括号和前面的类名共同构成了一个匿名对象, 由于匿名对象用完就释放, 所以可以进行一次性的仿函数操作 

