```
#include <iostream>
using namespace std;
int main(){
	int arr[5];
	int *p ;
	p = arr;
	return 0;
}
```

# 一、`arr[0]`的地址表示

| **#** | **表示方法**      | **说明**                                                                                 |
| ----- | ------------- | -------------------------------------------------------------------------------------- |
| **1** | **`&arr[0]`** | **最直接**的方法。使用地址运算符 (`&`) 获取数组第一个元素 `arr[0]` 的内存地址。                                     |
| **2** | **`arr`**     | 数组名 `arr` 在表达式中（除了用作 `sizeof` 的操作数或一元 `&` 运算符的操作数时），会被隐式地转换为指向其第一个元素的指针，与`arr[0]`完全等价。 |
| **3** | **`&arr`**    (特殊)   | 这个语句是的意思是对整个数组取地址，其结果在数值上是=`arr`=`&arr[0]`的。但是如果执行`&arr+1`操作，这个指针指向的是整个数组之后的内存，而不是`&arr[1]`。            |
| **4** | **`&p[0]`**   | 由于指针变量 `p` 已经指向了数组的起始位置（`arr`），所以 `p[0]` 等价于 `arr[0]`。同理，`&p[0]` 就表示 `arr[0]` 的地址。     |
| **5** | **`p`**       | 由于`p = arr;` 已经将数组 `arr` 的起始地址（即 `&arr[0]`）赋值给了指针 `p`。因此，指针变量 `p` 的值就是 `arr[0]` 的地址。   |

---
### 注：**`arr`** 一共有多种含义：
1. 作为数组名，本身是一个常量地址(不能执行赋值操作，比如++或者--)，但是`arr`并不是一个常量指针；
2. 作为数组首元素的地址，与`&arr[0]`完全等价；
3. 代表整个数组对象，比如用在`sizeof()`函数或者是一元`&`操作符。

### 注2：**`p[i]`** 的知识点：
1. ** 前提:**
 	(1)**p**必须是指针类型；
 	(2)**p**指向的位置后面必须要有连续的内存块；
 	(3)**i** 必须是连续内存块范围内的偏移量。
 2. **用途：**
 	可以用来访问第i个元素的值。而且可以和数组结合使用:
 	```
 	arr[i] = *(arr +1)
 	如果有p = arr;
 	则：p[i] = *(p +1) = arr[i];	
 	```
 3. **注意：**
    p不一定必须要指向数组的首位`arr[0]`,也可以指向其中某一个，比如`arr[2]`，只要指向的对象后面还有连续的内存块就行，当`p = &arr[2]`时，`p[0]=arr[2],p[1]=arr[3]`，也就是指针在这个内存块上移动。
 	$$\text{指针}[i] \equiv \text{从指针起点向后偏移 } i \text{ 个元素所得到的那个值}$$
---
# 二、`arr[0]`的值表示

|**#**|**表示方法**|**说明**|
| --- | ----------| ----- |
| **1** |**`arr[0]`**     |直接使用数组来表示。|
| **2** |**`*arr`**       |arr代表的就是数组首元素的地址，进行解引用操作即可得到`arr[0]`的值。|
| **3** |**`*(arr +0)`**   |使用指针算数，arr+0,得到首元素地址，然后解引用。|
| **4** |**`p[0]`**       |由`p[0]=arr[0]`得出。|
| **5** |**`*p`**         |由于`p=arr`，且`arr`是指向数组首元素的常量地址，所以直接对`p`进行解引用即可|
| **6** |**`*(p +0)`**    |因为p是指向`arr[0]`的指针，直接进行指针算数然后解引用即可。|

---
### 比较`p`和`arr`的异同：
* 不同点：
	* **`arr`** 是数组类型，储存的是5个int元素的值，占用的空间是五个`sizeof(int)`的值，即4字节，当arr作为指向首元素的指针时，其是一个常量，无法被重新赋值。
	* **`p`** 是指针类型，储存的是一个内存地址，占用的空间是`sizeof(int *)`的值，64位操作系统是8字节，且它是一个变量，可以重新赋值。
* 相同点：
	* 都可以使用`[i]`来访问数组元素：**`arr[i]=p[i]`**;
	* 都可以通过指针算数来访问数组元素：**`*(arr +i)=*(p +i)`**;
	* 对于首元素的访问有：`arr` 等价于 `p`.
---

# 三、`arr[i]`的地址表示  

|**#**|**表示方法**|**说明**|
| --- | ----------| ----- |  
| **1** |`&arr[i]`|经典取地址操作。|  
| **2** |`arr +i`|arr作为首元素地址的特性。|
| **3** |`&p[i]`|前提是`p=arr;`成立。|
| **4** |`p +i`|前提依然是`p=arr;`成立，这个具体情况具体分析。|

---

### 比较`arr[0]`和`arr[i](i不等于0)`地址表示方法的区别：
* 对于`arr[0]`来说，其地址表示多了一个`&arr` 这个情况出现的原因是：`arr`代表整个数组对象，取地址的时候取的是整个数组的地址，这个时候运算`&arr +1`得到的是数组后面的内存块，而不是`arr[1]`对应的地址，因此只有`arr[0]`有这种表示方法。
---
# 四、`arr[i]`的值表示

|**#**|**表示方法**|**说明**|
|---|---|---|
| **1** |**`arr[i]`**    |经典数组法。|
| **2** |**`*(arr + i)`**|利用arr作为首元素地址的特性，然后解引用。|
| **3** |**`p[i]`**      |前提是`p=arr`。|
| **4** |**`*(p + i)`**  |前提是`p=arr`。|

---
### 比较`arr[0]`和`arr[i]`的值表示方法的区别：
* 对于`arr[0]`来说，由于arr代表的是首元素地址，且`p=arr`，那么直接对`arr`取地址就可以得到`arr[0]`的值，或者对`p`取地址同理。
---
